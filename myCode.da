import sys
import time
from collections import defaultdict
from multiprocessing import Value


class Proposer(process):
    def setup(acceptors:set, quorumsize:int,
              f:float, nrounds:int, timeout:float, processManager):
        self.propNum = (0, self)          # Current proposal(ballot) number
        self.propVal = self          # Own value to propose
        self.flag=True

    def run():
        count = 0
        while flag and count < nrounds:
            work()
            --prepare
            send(('Prepare', propNum, self), to=acceptors)
            if await(len(setof(a, received(('Promise', _propNum, _, _, a)))) > quorumsize):
                --propose
                _, voted = max(setof((n, v),
                                     received(('Promise', _propNum, n, v, _)),
                                     len(setof(a,
                                               received(('Promise',
                                                         _propNum, _n, _v, a)))) > f) |
                               {((-1, self), propVal)})

                send(('OneC', propNum, voted, self), to=acceptors)
                if await(len(setof(a, received(('TwoAv', _propNum, _voted, a)))) > quorumsize):
                    --end
                    output("Succeeded proposing %s" % (voted,))
                    count += 1
                    continue
                elif timeout(timeout):
                    output("Failed to Propose in time, retrying.")
            elif timeout(timeout):
                output("Failed to Prepare in time, retrying.")
            propNum = (propNum[0] + 1, self)
        send(('Done',), to=acceptors)
        #
        ftime = time.time()
        send(('Finished', ftime), to=processManager)
        # output(f"P flag set {self.flag}")
    
    def receive(msg=('AllDone', n)):
        self.flag = False
        send(("AllDoneReceived", "Proposer"), to=processManager)
        output("P flag set")


class Acceptor(process):
    def setup(acceptors:set, proposers:set, quorumsize:int, f:float, processManager):
        self.peers = acceptors | proposers
        self.flag=True

    def run():
        while flag:
            if await(some(
                    received(('TwoAv', n, v, _)),
                    has=(len(setof(a, received(('TwoAv', _n, _v, a)))) >
                         quorumsize and
                         not sent(('TwoB', n, v))))):
                send(('TwoB', n, v), to=peers)
            elif each(p in proposers, has=received(('Done',), from_=p)):
                break

    def receive(msg=('Prepare', n, p)):
        if self.flag and n > maxpromised():
            vn, vv = max(setof((vpn, vv), sent(('TwoAv', vpn, vv, self))) |
                         {((-1, self), None)})
            send(('Promise', n, vn, vv, self), to=peers)

    def receive(msg=('OneC', n, v, p)):
        if self.flag and (n >= maxpromised() and islegal(n, v) and
                (not some(sent(('TwoAv', _n, _, self))))):
            send(('TwoAv', n, v, self), to=peers)
    
    def receive(msg=('AllDone', n)):
        self.flag = False
        send(("AllDoneReceived", "Acceptor"), to=processManager)
        output("A flag set")


    def maxpromised():
        return max(setof(n, sent(('Promise', n, _, _, _))) | {(-2, self)})

    def islegal(n, v):
        voted = setof((vn, vv), received(('Promise', _n, vn, vv, _)),
                      len(setof(a, received(('Promise', _n, _vn, _vv, a)))) > f)
        if voted and (max(voted)[1] is not None):
            return v == max(voted)[1]
        else:
            return True

class ProcessManager(process):

    def setup(nproposers, proposers, nacceptors, acceptors, nrounds, timeout): 
        self.beginTime = None
        self.index = 1
        self.totalN = nproposers

    def run():
        self.beginTime = time.time()
        await(self.totalN == 0)
        
    def logResult(ftime, timeUsed):
            with open("/home/ec2-user/measure.log", "a") as f:
                toWrite = repr({"nproposers":nproposers,
                    "nacceptors":nacceptors,
                    "nrounds":nrounds,
                    "timeout":timeout,
                    "ftime":ftime,
                    "timeUsed":timeUsed})
                f.write(toWrite + "\n")

    def receive(msg=('Finished', ftime), from_=p):
        timeUsed = ftime - self.beginTime
        output(f"{p} finished on {ftime}, time used: {timeUsed}")
        if self.index == 1:
            self.logResult(ftime, timeUsed)
            send(('AllDone', 1), to=proposers|acceptors)
        self.index += 1
        self.totalN -= 1
            
    def receive(msg=("AllDoneReceived", source), from_=p):
        # output(f"AllDoneReceived by {p}")
        return

class AddressAssignment:
    def __init__(self, addressL:list):
        self.__addressL = addressL
        self.__pointerDict = defaultdict(int)
    def getNextAddress(self, nodeType="default") -> str:
        addrPointer = self.__pointerDict[nodeType]
        self.__pointerDict[nodeType] = (addrPointer + 1) % len(self.__addressL)
        return self.__addressL[addrPointer]

def main():
    nproposers = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nacceptors = int(sys.argv[2]) if len(sys.argv) > 2 else 10
    nrounds = int(sys.argv[3]) if len(sys.argv) > 3 else 1
    timeout = int(sys.argv[4]) if len(sys.argv) > 4 else 1
    
    nodeFile = sys.argv[5] if len(sys.argv) > 5 else "../newDaAddr.config"
    nodeAddrL = None
    with open(nodeFile, "r") as f:
        nodeAddrStr = f.read()
        nodeAddrL = nodeAddrStr.split("\n")
    nodeAddrL = [addr for addr in nodeAddrL if addr != ""]
    assert len(nodeAddrL) > 0, "there must be at least one node (in the format NodeName@IP-Address)"
    addrAssign = AddressAssignment(nodeAddrL)
    
    f = int((nacceptors-1)/3)
    quorum = int(nacceptors/2 + f)
    print(f"props: {nproposers}, acpts: {nacceptors}, rnd: {nrounds}, tmot:{timeout}")
    
    acceptors, proposers = set(), set()
    for i in range(nacceptors):
        nodeAddr = addrAssign.getNextAddress(nodeType="acceptor")
        acceptors |= new(Acceptor, num=1, at=nodeAddr)

    for i in range(nproposers):
        nodeAddr = addrAssign.getNextAddress(nodeType="proposer")
        proposers |= new(Proposer, num=1, at=nodeAddr)

    processManager = new(ProcessManager)
    
    setup(acceptors, (acceptors, proposers, quorum, f, processManager))
    setup(proposers, (acceptors, quorum, f, nrounds, timeout, processManager))
    setup(processManager, (nproposers, proposers, nacceptors, acceptors, nrounds, timeout))
    start(processManager)
    start(acceptors)
    start(proposers)
    output("All acceptor and proposer processes initialized.")
    beginTime = time.time()
    while time.time() < beginTime + 10:
        time.sleep(0.5)
        output("Main: waiting")
    output("Ending processes")
    end(proposers|acceptors)
